"use strict";

const browserify = require('browserify');
const browserSync = require('browser-sync');
const chokidar = require('chokidar');
const gulp = require('gulp');
const pug = require('gulp-pug');
const rimraf = require('rimraf');
const sass = require('gulp-sass');
const babel = require('gulp-babel');
const source = require('vinyl-source-stream');
const typescript = require('gulp-typescript');

const SRC = './src';
const TMP = './.tmp';
const DEST = './public';

gulp.watch = function (glob, opt, task) {
    if (typeof opt === 'string' || typeof task === 'string' ||
        Array.isArray(opt) || Array.isArray(task)) {
        throw new Error('watching ' + glob + ': watch task has to be ' +
            'a function (optionally generated by using gulp.parallel ' +
            'or gulp.series)');
    }
    if (typeof opt === 'function') {
        task = opt;
        opt = {};
    }
    opt = opt || {};
    var fn;
    if (typeof task === 'function' && !opt.noDebounce) {
        var isActive = false;
        fn = () => (isActive || this.parallel(task)(() => isActive = false), isActive = true);
    } else {
        fn = this.parallel(task);
    }
    if (opt.wait) fn = _.debounce(fn, opt.wait);
    if (opt.ignoreInitial == null) opt.ignoreInitial = true;
    const watcher = chokidar.watch(glob, opt);
    if (fn) watcher.on('change', fn).on('unlink', fn).on('add', fn);
    return watcher;
};


gulp.task('script:compile', () => {
    return gulp.src(`${SRC}/scripts/**/*.ts`)
        .pipe(typescript({
            "declaration": true,
            "module": "commonjs",
            "moduleResolution": "node",
            "noFallthroughCasesInSwitch": true,
            "noImplicitReturns": true,
            "outDir": "./intermediate/",
            "removeComments": true,
            "sourceMap": true,
            "target": "es2015"
        }))
        .pipe(gulp.dest(TMP))
});

gulp.task('script:es5', () => {
    return gulp.src(`${TMP}/**/*.js`)
        .pipe(babel({
            presets: ['es2015']
        }))
        .pipe(gulp.dest(TMP));
});

gulp.task('script:browserify', () => {
    return browserify({
        entries: [`${TMP}/main.js`]
    })
        .bundle()
        .pipe(source('main.js'))
        .pipe(gulp.dest(`${DEST}/assets/scripts/`));
});

gulp.task('script', gulp.series('script:compile', 'script:es5', 'script:browserify'));

gulp.task('style', () => {
    return gulp.src(`${SRC}/styles/**/*.scss`)
        .pipe(sass())
        .pipe(gulp.dest(`${DEST}/assets/styles/`));
});

gulp.task('template', () => {
    return gulp.src(`${SRC}/*.pug`)
        .pipe(pug())
        .pipe(gulp.dest(DEST))
});

gulp.task('copy', () => {
    return gulp.src(`${SRC}/images/**/*.ico`)
        .pipe(gulp.dest(`${DEST}/assets/images/`))
});

gulp.task('clean', gulp.parallel(
        (cb) => rimraf(DEST, cb),
    (cb) => rimraf(TMP, cb)
));

gulp.task('watch', () => {
    const server = browserSync.create();
server.init({
    ui: {
        port: 3001
    },
    port: 3000,
    server: {
        baseDir: DEST,
    },
    reloadDelay: 1000
});

gulp.watch(`${SRC}/**/*.pug`, gulp.series('template'));
gulp.watch(`${SRC}/**/*.ts`, gulp.series('script'));
gulp.watch(`${SRC}/**/*.scss`, gulp.series('style'));
gulp.watch(`${SRC}/**/*.ico`, gulp.series('copy'));
gulp.watch(`${DEST}/**/*.html`, {noDebounce: true}, () => server.reload());
gulp.watch(`${DEST}/**/*.js`, {noDebounce: true}, () => server.reload());
gulp.watch(`${DEST}/**/*.css`, {noDebounce: true}, () => server.reload());
return server;
});

gulp.task('default', gulp.series('clean', gulp.parallel('script', 'style', 'template', 'copy'), 'watch'));
